const express = require('express');
const mysql = require('mysql2');
const allowLocalOnly = require('./allowLocalOnly');
const router = express.Router();


const dropTable = {
    prototech_frame: 11, prototech_panel: 4, prototech_capacitor: 4, prototech_propulsion_unit: 4,
    prototech_machinery: 4, prototech_circuitry: 4, prototech_cooling_unit: 8,
    DefenseUpgradeModule_Level1: 1, DefenseUpgradeModule_Level2: 2, DefenseUpgradeModule_Level3: 3,
    DefenseUpgradeModule_Level4: 4, DefenseUpgradeModule_Level5: 5, DefenseUpgradeModule_Level6: 6,
    DefenseUpgradeModule_Level7: 7, DefenseUpgradeModule_Level8: 8, DefenseUpgradeModule_Level9: 9,
    DefenseUpgradeModule_Level10: 10,
    AttackUpgradeModule_Level1: 1, AttackUpgradeModule_Level2: 2, AttackUpgradeModule_Level3: 3,
    AttackUpgradeModule_Level4: 4, AttackUpgradeModule_Level5: 5, AttackUpgradeModule_Level6: 6,
    AttackUpgradeModule_Level7: 7, AttackUpgradeModule_Level8: 8, AttackUpgradeModule_Level9: 9,
    AttackUpgradeModule_Level10: 10,
    PowerEfficiencyUpgradeModule_Level1: 1, PowerEfficiencyUpgradeModule_Level2: 2, PowerEfficiencyUpgradeModule_Level3: 3,
    PowerEfficiencyUpgradeModule_Level4: 4, PowerEfficiencyUpgradeModule_Level5: 5, PowerEfficiencyUpgradeModule_Level6: 6,
    PowerEfficiencyUpgradeModule_Level7: 7, PowerEfficiencyUpgradeModule_Level8: 8, PowerEfficiencyUpgradeModule_Level9: 9,
    PowerEfficiencyUpgradeModule_Level10: 10,
    BerserkerModule_Level1: 11, BerserkerModule_Level2: 12, BerserkerModule_Level3: 13,
    BerserkerModule_Level4: 14, BerserkerModule_Level5: 15, BerserkerModule_Level6: 16,
    BerserkerModule_Level7: 17, BerserkerModule_Level8: 18, BerserkerModule_Level9: 19,
    BerserkerModule_Level10: 20,
    SpeedModule_Level1: 11, SpeedModule_Level2: 12, SpeedModule_Level3: 13,
    SpeedModule_Level4: 14, SpeedModule_Level5: 15, SpeedModule_Level6: 16,
    SpeedModule_Level7: 17, SpeedModule_Level8: 18, SpeedModule_Level9: 19,
    SpeedModule_Level10: 20,
    FortressModule_Level1: 11, FortressModule_Level2: 12, FortressModule_Level3: 13,
    FortressModule_Level4: 14, FortressModule_Level5: 15, FortressModule_Level6: 16,
    FortressModule_Level7: 17, FortressModule_Level8: 18, FortressModule_Level9: 19,
    FortressModule_Level10: 20
  };
// MySQL 연결 설정
const connection = mysql.createConnection({
  host: process.env.DB_HOST || 'localhost',
  user: process.env.DB_USER || 'root',
  password: process.env.DB_PASSWORD || 'my-secret-pw',
  database: process.env.DB_NAME || 'mydatabase',
  supportBigNumbers: true,
  bigNumberStrings: true
});
function getDrop(damage) {
  const maxDropChance = 0.8; // 최대 드랍 확률 80%
  const dropChance = Math.min(damage / 62, maxDropChance); // 피해량 50일 때 dropChance는 약 0.8

  if (Math.random() > dropChance) {
    return null; // 드랍 없음
  }

  // 아이템 희귀도에 따라 가중치 설정 (지수 함수 적용)
  let adjustedWeights = {};
  let totalWeight = 0;

  for (const [item, rarity] of Object.entries(dropTable)) {
    const adjustedWeight = Math.pow(0.4, rarity); // 희귀도가 높을수록 가중치가 지수적으로 감소
    adjustedWeights[item] = adjustedWeight;
    totalWeight += adjustedWeight;
  }

  // 확률을 정규화하여 총합이 1이 되도록 설정
  for (const item in adjustedWeights) {
    adjustedWeights[item] /= totalWeight;
  }

  const randomValue = Math.random();
  let accumulatedProbability = 0;

  for (const [item, probability] of Object.entries(adjustedWeights)) {
    accumulatedProbability += probability;
    if (randomValue <= accumulatedProbability) {
      return item; // 아이템 드랍
    }
  }

  return null; // 이론적으로는 여기까지 오지 않음
}function allowLocalOnly(req, res, next) {
  const localIps = ['61.72.176.150', '::1'];

  // 요청의 IP 주소가 로컬 IP인지 확인
  const requestIp = req.ip;

  if (localIps.includes(requestIp)) {
    // 로컬 IP에서 요청이 들어왔을 때만 다음 미들웨어로 이동
    next();
  } else {
    // 로컬 IP가 아닌 경우 접근 제한 응답
    res.status(403).json({ error: 'Access restricted to local only' });
  }
}

router.get('/admin/api/resources/:steamid', allowLocalOnly, (req, res) => {
  const steamId = req.params.steamid;
  const query = 'SELECT * FROM online_storage WHERE steam_id = ?';

  connection.query(query, [steamId], (err, results) => {
    if (err) return res.status(500).json({ error: 'Database error' });
    res.json({ steamid: steamId, resources: results[0] || 'No data' });
  });
});

router.get('/admin/api/damage/:steamid', allowLocalOnly, (req, res) => {
  const steamId = req.params.steamid;
  const query = 'SELECT * FROM damage_logs WHERE steam_id = ?';

  connection.query(query, [steamId], (err, results) => {
    if (err) return res.status(500).json({ error: 'Database error' });
    res.json({ steamid: steamId, totalDamage: results.length > 0 ? results[0].total_damage : 0 });
  });
});

router.get('/admin/api/coin_balance/:steamid', allowLocalOnly, (req, res) => {
  const steamId = req.params.steamid;
  const query = 'SELECT * FROM coin_balance WHERE steam_id = ?';

  connection.query(query, [steamId], (err, results) => {
    if (err) return res.status(500).json({ error: 'Database error' });
    res.json({ steamid: steamId, coin_balance: results.length > 0 ? results[0].sek_coin_balance : 0 });
  });
});
app.post('/api/damage_logs', async (req, res) => {
    const damageLogs = req.body;
    console.log('Received damage logs:', req.body);
  
    if (!Array.isArray(damageLogs) || damageLogs.length === 0) {
      console.log('Invalid damage log data');
      return res.status(400).json({ error: 'Invalid data' });
    }
  
    try {
      // 모든 로그를 비동기적으로 처리
      await Promise.all(damageLogs.map(log => {
        let { steam_id, total_damage } = log;
  
        if (!steam_id || total_damage === undefined) {
          console.log('Invalid log data:', log);
          return Promise.resolve();  // 잘못된 데이터는 무시
        }
  
        steam_id = BigInt(steam_id); // Steam ID를 문자열로 처리
  
        // 손상 로그 저장과 계좌 업데이트를 동시에 처리
        const insertDamageLogQuery = `
          INSERT INTO damage_logs (steam_id, total_damage)
          VALUES (?, ?)
          ON DUPLICATE KEY UPDATE total_damage = total_damage + VALUES(total_damage);
        `;
  
        const updateCoinBalanceQuery = `
          INSERT INTO coin_balance (steam_id, sek_coin_balance)
          VALUES (?, ?)
          ON DUPLICATE KEY UPDATE sek_coin_balance = sek_coin_balance + ?;
        `;
  
        return new Promise((resolve, reject) => {
          // 피해 로그 저장
          connection.query(insertDamageLogQuery, [steam_id.toString(), total_damage], (err, result) => {
            if (err) {
              console.log('Error saving damage log:', err);
              return reject(err);
            }
            console.log(`Damage log for Steam ID ${steam_id} successfully saved with damage ${total_damage}.`);
  
            // 계좌에 코인 추가
            connection.query(updateCoinBalanceQuery, [steam_id.toString(), total_damage, total_damage], (coinErr, coinResult) => {
              if (coinErr) {
                console.log('Error updating coin balance:', coinErr);
                return reject(coinErr);
              }
              console.log(`Coin balance updated for Steam ID ${steam_id} by adding ${total_damage/10} coins.`);
              resolve();
            });
          });
        });
      }));
  
      res.send('Damage logs and coin balances updated successfully');
    } catch (err) {
      console.log('Error processing damage logs and updating coin balances:', err);
      res.status(500).json({ error: 'Failed to process damage logs and update coin balances' });
    }
  });
module.exports = router;
